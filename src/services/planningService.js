import api from './api';
import { API_ENDPOINTS, FEATURE_FLAGS } from '../utils/constants';
import { MOCK_DATA } from '../utils/mockData';

class PlanningService {
  /**
   * Get all auto-generated plans
   * @param {Object} params - Query parameters
   * @param {string} params.status - Filter by status
   * @param {string} params.planType - Filter by plan type
   * @param {number} params.limit - Pagination limit
   * @param {number} params.page - Page number
   */
  async getAllPlans(params = {}) {
    // Return mock data if feature flag is enabled
    if (FEATURE_FLAGS.USE_MOCK_DATA) {
      return MOCK_DATA.plans;
    }

    try {
      const response = await api.get(API_ENDPOINTS.PLANNING, { params });
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Get only active plans (auto-generated by system)
   */
  async getActivePlans() {
    // Return mock data if feature flag is enabled
    if (FEATURE_FLAGS.USE_MOCK_DATA) {
      return MOCK_DATA.activePlans;
    }

    try {
      const response = await api.get(API_ENDPOINTS.PLANNING_ACTIVE);
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Get specific plan by ID
   * @param {string} planId - Plan ID
   */
  async getPlanById(planId) {
    // Return mock data if feature flag is enabled
    if (FEATURE_FLAGS.USE_MOCK_DATA) {
      return MOCK_DATA.plans.find(p => p._id === planId) || MOCK_DATA.plans[0];
    }

    try {
      const endpoint = API_ENDPOINTS.PLANNING_BY_ID.replace(':planId', planId);
      const response = await api.get(endpoint);
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Get plan insights (why this plan was created)
   * @param {string} planId - Plan ID
   */
  async getPlanInsights(planId) {
    try {
      const endpoint = API_ENDPOINTS.PLANNING_INSIGHTS.replace(':planId', planId);
      const response = await api.get(endpoint);
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Trigger manual AI analysis to generate new plans
   * Forces the system to check performance NOW
   */
  async triggerAnalysis() {
    try {
      const response = await api.post(API_ENDPOINTS.PLANNING_ANALYZE);
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Update plan status (Accept/Reject/Complete/Archive)
   * @param {string} planId - Plan ID
   * @param {string} status - New status ('active' | 'completed' | 'cancelled' | 'archived')
   * @param {string} notes - Optional notes
   */
  async updatePlanStatus(planId, status, notes = '') {
    try {
      const endpoint = API_ENDPOINTS.PLANNING_STATUS.replace(':planId', planId);
      const response = await api.patch(endpoint, { status, notes });
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Accept a plan (set status to 'active')
   * @param {string} planId - Plan ID
   */
  async acceptPlan(planId) {
    return this.updatePlanStatus(planId, 'active', 'Plan accepted by user');
  }

  /**
   * Reject a plan (set status to 'cancelled')
   * @param {string} planId - Plan ID
   */
  async rejectPlan(planId) {
    return this.updatePlanStatus(planId, 'cancelled', 'User rejected plan');
  }

  /**
   * Complete a plan
   * @param {string} planId - Plan ID
   */
  async completePlan(planId) {
    return this.updatePlanStatus(planId, 'completed');
  }

  /**
   * Archive a plan
   * @param {string} planId - Plan ID
   */
  async archivePlan(planId) {
    return this.updatePlanStatus(planId, 'archived');
  }

  /**
   * Update action item (mark complete, change status, etc.)
   * @param {string} planId - Plan ID
   * @param {string} actionId - Action item ID
   * @param {Object} updates - Action item updates
   */
  async updateActionItem(planId, actionId, updates) {
    try {
      const endpoint = API_ENDPOINTS.PLANNING_ACTION_ITEM
        .replace(':planId', planId)
        .replace(':actionId', actionId);
      const response = await api.patch(endpoint, updates);
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Mark action item as complete
   * @param {string} planId - Plan ID
   * @param {string} actionId - Action item ID
   */
  async completeActionItem(planId, actionId) {
    return this.updateActionItem(planId, actionId, { status: 'completed' });
  }

  /**
   * Update milestone
   * @param {string} planId - Plan ID
   * @param {string} milestoneId - Milestone ID
   * @param {Object} updates - Milestone updates
   */
  async updateMilestone(planId, milestoneId, updates) {
    try {
      const endpoint = API_ENDPOINTS.PLANNING_MILESTONE
        .replace(':planId', planId)
        .replace(':milestoneId', milestoneId);
      const response = await api.patch(endpoint, updates);
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Get plan statistics
   * @param {Object} params - Query parameters
   * @param {string} params.startDate - Optional start date
   * @param {string} params.endDate - Optional end date
   */
  async getPlanStatistics(params = {}) {
    try {
      const response = await api.get(API_ENDPOINTS.PLANNING_STATS, { params });
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Record actual results for a plan (LEARNS feature)
   * @param {string} planId - Plan ID
   * @param {Object} actualMetrics - Actual metrics achieved
   * @param {string} notes - Optional notes about the results
   */
  async recordPlanResults(planId, actualMetrics, notes = '') {
    try {
      const endpoint = API_ENDPOINTS.PLANNING_RECORD_RESULTS.replace(':planId', planId);
      const response = await api.post(endpoint, {
        metrics: actualMetrics,
        notes
      });
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Get plan performance metrics (LEARNS feature)
   * @param {string} planId - Plan ID
   */
  async getPlanPerformance(planId) {
    try {
      const endpoint = API_ENDPOINTS.PLANNING_PERFORMANCE.replace(':planId', planId);
      const response = await api.get(endpoint);
      return response.data || response;
    } catch (error) {
      throw error;
    }
  }
}

export default new PlanningService();
